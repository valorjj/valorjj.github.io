---
title: spring mircoservices-01
date: 2023-10-19 00:00 +09:00
categories: ["springboot", "msa"]
tags: 
- "docker"
- "kubernetes"
- "gcp"
image:
    path: spring.png
    alt: ""
---

# MSA 장점

# MSA 단점

# MSA 전체구조

# GCP 사용하기

> Jenkins, Kubernetes 를 배포하기 위해서 Google Cloud Platform 을 사용한다.
> GCP 내에서 VM 을 생성하여 Debian/Ubuntu 내에서 작업이 이루어진다.

## VM 인스턴스 생성

asia-northeast3 (Seoul) 을 선택하고 VM 을 하나 생성한다. default 설정을 사용한다면 Debian 이 OS 로 설치된다. 해당 VM 에 설치된 서버에 프로젝트를 배포하는 것이 목표이다.

- Cloud NAT 생성
- VPC Network > Firewall > TCP 8080 포트 개방

<img width="597" alt="image" src="https://user-images.githubusercontent.com/30681841/278440200-564e9504-5792-4ace-b7d7-f7b4c9de5b94.png">

<img width="543" alt="image" src="https://user-images.githubusercontent.com/30681841/278441500-3bc209fd-9c67-4af1-bf91-e1d4ebc748ff.png">

jenkins 에 접근하는 포트인 8080 을 열어서 `${VM IP 주소}:8080` 으로의 접속을 허용한다.



## Jenkins 설치

```bash
# 1.
sudo wget -O /usr/share/keyrings/jenkins-keyring.asc \
  https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key
# 2.
echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
  https://pkg.jenkins.io/debian-stable binary/ | sudo tee \
  /etc/apt/sources.list.d/jenkins.list > /dev/null
sudo apt-get update
sudo apt-get install jenkins

# git, kubectl
sudo apt-get install git
sudo apt-get install kubectl
```

## Java 설치

커뮤니티 기반 빌드인 AdoptOpenJDK 가 많이 사용되는데, 최근 Eclipse Adoptium 으로 이전했다. docker-hub 에 등록된 openjdk 를 들어가보면 더 이상 관리되지 않으며 Azul, Temurin 등 다른 jdk 사용을 권장하고 있다.

Debian/Ubuntu 기준으로 설치는 아래 명령어를 순서대로 입력하면 된다.

```bash
# 1.
sudo apt install -y wget apt-transport-https
# 2.
sudo mkdir -p /etc/apt/keyrings
# 3.
sudo wget -O - https://packages.adoptium.net/artifactory/api/gpg/key/public | sudo tee /etc/apt/keyrings/adoptium.asc
# 4.
echo "deb [signed-by=/etc/apt/keyrings/adoptium.asc] https://packages.adoptium.net/artifactory/deb $(awk -F= '/^VERSION_CODENAME/{print$2}' /etc/os-release) main" | sudo tee /etc/apt/sources.list.d/adoptium.list
# 5.
sudo apt update
# 6.
sudo apt install temurin-17-jdk
```

## Jenkins 설정

github, gcp 와 연결하기 위해서 token 을 등록해야한다. Crendentials 로 이동한다.

- repo 를 관리할 수 있는 권한을 가진 토큰 
- gcp 에서 IAM 으로 이동, service account 생성
  - keys 로 이동해서 JSON 타입의 key 를 생성 (파일로 다운로드 됨)
    - gcp 에 접근하기 위한 credential
      - secret file
    - google 계정을 인증하기 위한 credential 총 2개 생성
      - google account 어쩌고 저쩌고
- jenkins 에서 plugin 설치
  - Google Kubernetes Engine 설치


## Kubernetes Cluster 생성

Private cluster 로 GKE 클러스터를 생성한다. 여기서 설정하는 몇몇 설정, 특히 네트워크 관련 설정은 Cluster 생성 후 변경이 불가능하니 주의가 필요하다.

<img width="548" alt="image" src="https://user-images.githubusercontent.com/30681841/278410555-7fa8d757-17ed-4b86-8aa9-0c015839769f.png">

private 으로 설정해서 외부로 IP 가 노출되도록 설정한 인스턴스 이외에는 접근할 수 없도록 한다. 
그럼 2가지 경고 메시지를 볼 수 있다.

- (1) 클러스터를 생성하고 나서 Cloud NAT 를 통해 아웃바운드 인터넷 연결을 활성화 시켜라
- (2) 컨트롤 플레인이 허용한 네트워크를 활성화 시켜라

나처럼 초보자는 여기서 헤매기 딱 좋은 키워드가 있다.

- VPC
- NAT
- Subnet
- CIDR ([참고](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-CIDR-%EC%9D%B4-%EB%AC%B4%EC%96%BC-%EB%A7%90%ED%95%98%EB%8A%94%EA%B1%B0%EC%95%BC-%E2%87%9B-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC-%EA%B3%84%EC%82%B0%EB%B2%95#recentEntries))

관련해서 구글이 제공하는 도움말 링크 모음은 다음과 같다.

- [비공개 클러스터 만들기](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters?hl=ko)
- [GKE 의 비공개 클러스터](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept?hl=ko)
  - [IP 주소](https://cloud.google.com/vpc/docs/ip-addresses?hl=ko)
- [유효한 IPv4 범위](https://cloud.google.com/vpc/docs/subnets?hl=ko#valid-ranges)
- [VPC 기반 클러스터](https://cloud.google.com/kubernetes-engine/docs/concepts/alias-ips?hl=ko)
- [VPC 네트워크 피어링](https://cloud.google.com/kubernetes-engine/docs/concepts/alias-ips?hl=ko)
- [Cloud NAT 개요](https://cloud.google.com/nat/docs/overview?hl=ko#NATwithGKE)
  - [GKE 에서 Public NAT 사용](https://cloud.google.com/nat/docs/gke-example?hl=ko)
    - [Public NAT](https://cloud.google.com/nat/docs/public-nat?hl=ko)
    - 

- [k8s 에서 네트워킹]({% post_url 2023-10-26-k8s_networking %})

Cluster 관련해서 짧은 시간에 핵심만 요약한 영상 자료는 다음을 참고한다. 

{% include embed/youtube.html id='QvVmQtO-ftU' %}

가장 위에 알림이 뜨는데, 더 이상 `kube-dns` 를 사용하지 않고 `Cloud DNS` 를 사용한다는 알림이다.

<img width="534" alt="image" src="https://user-images.githubusercontent.com/30681841/278551183-e5c88748-a279-47b9-ba08-777801877607.png">



---

## Jenkins 파이프라인 구성

- k8s 배포를 위한 YAML 파일
- Jenkinsfile 

2가지를 준비해야 한다.

스프링이 제공하는 spring-cloud config-server 를 사용하기 위한 config-server 를 배포해보자.

`deployment.yml`

```yaml
# @format
---
## Deployment

apiVersion: apps/v1
kind: Deployment
metadata:
  name: config-server-app
spec:
  selector:
    matchLabels:
      app: config-server-app
  template:
    metadata:
      labels:
        app: config-server-app
    spec:
      containers:
        - name: config-server-app
          image: IMAGE_URL/config-server
          imagePullPolicy: Always
          ports:
            - containerPort: 9296
          resources:
            requests:
              memory: "100Mi"
              cpu: "250m"
            limits:
              memory: "200Mi"
              cpu: "500m"

---
## Service

apiVersion: v1
kind: Service
metadata:
  name: config-server-svc
spec:
  selector:
    app: config-server-app
  ports:
    - port: 80
      targetPort: 9296

```

Jenkins 에 등록한 환경변수를 호출한다. 환경변수는 다음과 같다.

- Artifact Registry 정보
- 프로젝트 정보
- Zone 정보
- Jenkins 에 등록한 github credentials
- GCP 에 로그인하기 위한 credentials


```jenkins
node {
    def repoURL = "${REGISTRY_URL}/${PROJECT_ID}/${ARTIFACT_REGISTRY}"

    stage('Github Repository Checkout') {
        checkout([$class: 'GitSCM',
            branches: [[name: '*/main']],
            extensions: [],
            userRemoteConfigs: [[credentialsId: 'git', 
            url: 'https://github.com/valorjj/config-server.git']]
        ])
    }

    stage('Build and Push Image to Google Cloud Artifact Registry') {
        // jenkins 에 등록한 gcp 인증 정보
        withCredentials([file(credentialsId: 'gcp', variable: 'GC_KEY')]) {
            // 젠킨스에 업로드한 서비스 계정의 자격증명을 통해 Artifact Registry 를 인증한다. 
            sh("gcloud auth activate-service-account --key-file=${GC_KEY}")
            // credHelper 를 통해서 Artifact Registry 에서 도커를 사용할 수 있게한다.
            sh("gcloud auth configure-docker ${REGISTRY_URL}")
            // gradle 에서 jib 작동 확인
            // 프로젝트 빌드 후 .jar 파일 생성, (build.gradle 에 변수 할당)
            sh("./gradlew clean jib -DREPO_URL=${repoURL}") 
        }
    }

    stage('Deploy to GKE') {
        // 쿠버네티스 배포 파일에 변수 할당
        sh("sed -i 's|IMAGE_URL|${repoURL}|g' k8s/deployment.yml")
        
        step([$class: 'KubernetesEngineBuilder',
            projectId: env.PROJECT_ID,
            clusterName: env.CLUSTER,
            location: env.ZONE,
            manifestPattern: 'k8s/deployment.yml',
            credentialsId: env.GOOGLE_SERVICE_ACCOUNT_CREDENTIAL,
            verifyDeployments: true])
    }
}
```

<img width="894" alt="image" src="https://user-images.githubusercontent.com/30681841/278436918-556f8b63-e065-49ec-97aa-f37a39355774.png">

github 로 push 와 동시에 build, 그리고 jenkins 에 kubernetes 플러그인을 통하여 GKE 로 배포까지 완료되도록 설정한다. 브랜치는 */main 뿐 아니라 여러개를 설정할 수 있다.

다만, 이러한 파이프라인이 작동하기 위해서는 github repo 에 webhook 을 설정해야 한다.

<img width="1119" alt="image" src="https://user-images.githubusercontent.com/30681841/278437644-68476f51-c77a-4faa-bcad-fe7063d3c13f.png">

위에서 secret 은 Jenkins 의 설정에서 생성한 token 이다.

젠킨스에서 파이프라인 구성 후에 Build now (지금 빌드) 를 누르면 github 에서 정보를 받아온다. 한번 빌드 후에는 github 로 push 와 동시에 CD/CI 과정이 진행된다.

여기까지 중요한 포인트만 정리해보자.

1. Serverless 서비스를 위한 플랫폼으로 GCP 를 사용한다.
2. GCP 에서 제공하는 GKE 를 사용한다.
   1. Dockerhub 가 아닌 구글이 제공하는 Artifact Registry 를 사용한다.
   2. Cluster 를 생성한다.
   3. Cloud NAT 를 생성하여 클러스터 내에서 서비스-to-서비스 통신이 원활하게 이루어지도록 한다.
3. 젠킨스를 띄울 VM 을 생성한다.
   1. 젠킨스를 설치하고 각종 환경변수, 인증서를 등록한다.
   2. 젠킨스에서 파이프라인을 구성한다.
      1. github, gke 의 인증을 위해서 위에서 등록한 인증 정보를 사용한다.
4. github 에 push 하면 젠킨스를 통해 빌드 후 k8s 로 배포가 완료된다. 


---

# 각 서비스에 관한 설명

## 보안 설정

보안에 관련된 부분은 검색해보면 너무나도 방법이 다양하다. 단순화하여 큰 그림을 보는 것이 목적이므로 Okta 에 인증, 인가를 위임했다.

모든 api 콜의 수문장 역할을 맡는 cloud-gateway 에서 사용자가 토큰을 가지고 있는지, 가지고 있다면 어떤 권한을 가진 유저인지 판단한다.

---

# HTTPS 연결 삽질기록

***가비아***에서 도메인을 구매 후, HTTPS 연결을 위한 시도, 실패했지만 나중을 위해 기록으로 남겨둔다.

(HTTP 연결은 매우 간단했다.)

## HTTPS 를 위해 알아두어야 하는 개념

HTTP 통신을 기본으로 깔되 오가는 패킷을 두꺼운 보안으로 감싼다고 생각하자. 







# 출처

1. [https://s-core.co.kr/insight/view/spring-cloud-gateway-%EA%B8%B0%EB%B0%98%EC%9D%98-api-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4-%EA%B5%AC%EC%B6%95/](https://s-core.co.kr/insight/view/spring-cloud-gateway-%EA%B8%B0%EB%B0%98%EC%9D%98-api-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4-%EA%B5%AC%EC%B6%95/)
2. 