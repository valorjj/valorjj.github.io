---
title: JPA 관한 기록
date: 2023-11-11 00:00 +09:00
categories: ['springboot', 'jpa']
image:
  path: spring.png
  alt: ''
---

<!-- @format -->
> Eraser 를 이용해 만든 직접 자료입니다. <br/>
> 공부하면 할수록 어려운 JPA 를 정리합니다 😭

## 영속성 컨텍스트

- *영속성 컨텍스트*는 `@Id` 필드를 기준으로 엔티티를 식별
- `persist()` 시, `1차 캐시` 에 저장
  - 해당 엔티티의 상태는 `Managed` 가 됨
  - `EntityManager` 가 `commit()` 을 호출하면, 쓰기 지연 저장소에 캐싱된 SQL 이 ***DB 에 반영***됨
    - `commit() `메서드 호출 시, `flush()` 일어남
    - SQL 문은 `flush()` 과정을 통해 DB 에 반영
      - 단, `flush()` 는 1차 캐시를 비우는 `clear()` 를 발생시키지 않음
  - `clear()` 실행 시
    - *영속성 컨텍스트*에서 엔티티 제거
    - 1차 캐시 초기화
    - 엔티티를 다시 로딩
    - 이전 엔티티들은 준영속 상태로 변경
      -  변경 사항 존재해도 DB 에 반영 X
      -  한 트랙잭션 내에서 이전에 변경한 내용이 있다면 모두 롤백된다.
- `close()` 실행 시
  - 영속성 컨텍스트의 완전 종료


![image](https://user-images.githubusercontent.com/30681841/283708881-0450a058-2e6f-436c-a39e-2e76b948805b.png)

## 1차 캐시

![image](https://user-images.githubusercontent.com/30681841/283708939-0d26653b-e7e1-4c14-9bd9-a4e16cfac59c.png)


## Dirty Checking

![image](https://user-images.githubusercontent.com/30681841/283709063-b13609a8-306c-4205-9b9a-6f5e0c034976.png)

### 쓰기 지연 저장소

![image](https://user-images.githubusercontent.com/30681841/283714548-e3d0cecb-89d2-4067-ac59-0868aa302593.png)

위 그림은 캐시된 SQL 이 어느정도 모였다가 한번에 DB 로 flush 되는 과정을 나타낸다. 어느정도라는 말은 수치를 개발자가 정할 수 있다는 것이다. 

#### batch_fetch_size

복잡한 조회쿼리 작성 시, 지연로딩으로 발생하는 쿼리는 `IN 절`로 한번에 묶어서 보낼 수 있다. 지연로딩 시 호출될 엔티티를 프록시 객체로 저장해두었다가, ***실제 사용하는 시점***에 DB 에서 가져온다고 이해하자.

`hibernate.default.batch_fetch_size` 옵션을 전역적으로 부여할 수도 있고,
혹은 어노테이션으로 개별 옵션 지정도 가능하다.
```java
@OneToMany
@BatchSize(size = 3)
```

지연로딩을 할 수 없는 경우, Batch 옵션을 고려한다. 


관련된 재밌는 글이 있어 기록한다.

출처: [BatchSize 에 따른 Heap 메모리 분석](https://prasanthmathialagan.wordpress.com/2017/04/20/beware-of-hibernate-batch-fetching/) 


Heap Dump Report
```bash
num     #instances         #bytes  class name
----------------------------------------------
   1:        727727      235191336  [C
   2:       1949160       48144472  [Ljava.lang.String;
   3:        171172       21921824  
   4:        171172       21581600  
   5:        727337       17456088  java.lang.String
   6:         13770       16400304  
   7:        331148       10596736  java.util.HashMap$Entry
   8:         13770       10483088  
   9:         96859        9298464  org.hibernate.loader.entity.EntityLoader
  10:        125190        8366608  [[Ljava.lang.String;
  11:        140946        6765408  java.util.HashMap
  12:          8927        6644608  
  13:        145303        5812120  java.util.LinkedHashMap$Entry
  14:         52938        5595736  [Ljava.util.HashMap$Entry;
  15:         47148        4732600  [B
  16:        110339        4413560  org.hibernate.loader.DefaultEntityAliases
  17:         41846        3347680  java.lang.reflect.Method
  18:         44019        3169368  java.lang.reflect.Field
  19:         97394        3116608  org.hibernate.LockOptions
  20:         99327        2412328  [Lorg.hibernate.type.EntityType;
  21:         99327        2412328  [Lorg.hibernate.LockMode;
  22:         99326        2412304  [Lorg.hibernate.persister.entity.Loadable;
  23:         99326        2412304  [Lorg.hibernate.loader.EntityAliases;
  24:         41633        2331448  java.util.LinkedHashMap
  .
  .
  .
  .
  60:          9685         309920  org.hibernate.loader.entity.BatchingEntityLoader
  ```


BatchSize 에 따른 메모리 분석
|Batch fetch size|Heap memory usage(MB)|EntityLoader instances|EntityLoader memory usage(MB)|String memory usage(MB)|char[] memory usage(MB)|
|---|---|---|---|---|---|
|1|363|13864|1.3|13|81.5|
|2|404|27724|2.6|14.5|109|
|3|446|41584|4|16.1|137|
|4|493|55444|5.3|17.7|166|
|5|532|69304|6.6|19.2|194|
|7|621|97024|9.3|22.4|253|
|10|753|138604|13.3|27.1|342|
|15|797|152464|14.6|28.6|373|
|20|796|152464|14.6|28.6|374|
|30|836|166324|15.9|30.2|408|
|50|889|180184|17.3|31.7|446|

### LazyLoading

> 엔티티를 프록시 객체로 영속성 컨텍스트에 보관하고, 필요한 시점에 쿼리문을 날린다.

```java
@Entity
public class Store {

  @OneToMany(mappedBy = "store")
  private List<Employee> employees = new ArrayList<>();

}

@Entity
public class Employee {

  @ManyToOne
  @JoinColumn(name="store_id")
  private Store store;

}
```

![image](https://user-images.githubusercontent.com/30681841/283726750-643de3a8-2da4-45b3-bfb2-2a16c631d575.png)

Store 를 조회하면, 각 Store 와 연관관계를 맺고 있는 Employee 들도 모두 조회된다. 물론 이렇게 사용해야 하는 경우도 있겠지만, 불필요한 쿼리를 날리는 상황이 더 많을 것이다.

따라서, `@ManyToOne` 에 옵션을 주어 기본 설정을 바꿔야한다.

```java
@Entity
public class Store {

  @Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @OneToMany(mappedBy = "store")
  private List<Employee> employees = new ArrayList<>();

}

@Entity
public class Employee {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY) 
  private Long id;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name="store_id")
  private Store store;

}
```

이처럼 `LazyLoading` 을 사용하는 경우, `Store` 를 조회하면 `Store` 만을 조회한다. 그럼 `Employee` 객체는 어떻게 되는건가? 연관관계를 맺고 있기 때문에, JPA 는 이를 `Proxy 객체`로 생성해 `1차 캐시`에 저장해둔다. 

위에서 `1차 캐시`에는 `@Id` 기준으로 엔티티를 식별하는 것을 알았다. 따라서 `Employee` 의 `@Id` 기준으로 `1차 캐시`에 저장해둔다.  
-> @Id 값을 이미 가지고 있기 때문에 Store 조회 시, `Employee.getId()` 해도 `N+1` 문제가 발생하지 않는다.
-> 다른 필드에 접근하면, 그 시점에 쿼리문이 발생한다.

다만, 지연 로딩을 설정하고 join 문을 실행해서 데이터를 조회하면 그 유명한 `N+1` 문제가 발생한다.  일반 join 문으로 쿼리를 날리면, 조회 대상 엔티티 단 1개만 영속화되어 영속성 컨텍스트에서 관리되고, join 대상에 해당하는 엔티티는 영속성 컨텍스트에 

## Cascade

연관관계를 부여하면, 제약조건이 생성된다. 제약조건이 걸린 엔티티들 간의 변화에 어떻게 대응할지 전략을 선택해야 한다.





---

# 출처

- [https://www.setgetweb.com/p/wxs70/com.ibm.websphere.extremescale.over.doc/cxscchbeh.html]
(https://www.setgetweb.com/p/wxs70/com.ibm.websphere.extremescale.over.doc/cxscchbeh.html)
- [https://www.baeldung.com/spring-transactions-read-only](https://www.baeldung.com/spring-transactions-read-only)
- [https://everydayyy.tistory.com/157](https://everydayyy.tistory.com/157)
- [https://siyoon210.tistory.com/138](https://siyoon210.tistory.com/138)
- [https://gmlwjd9405.github.io/2019/08/06/persistence-context.html](https://gmlwjd9405.github.io/2019/08/06/persistence-context.html)
- [https://jongminlee0.github.io/2020/02/11/jpa5/](https://jongminlee0.github.io/2020/02/11/jpa5/)
- [https://victorydntmd.tistory.com/207](https://victorydntmd.tistory.com/207)
- [https://velog.io/@chosj1526/JPA-commit%EA%B3%BC-flush%EC%97%90-%EA%B4%80%ED%95%B4-%EC%98%81%EC%86%8D-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EC%84%B8%EC%84%B8%ED%95%98%EA%B2%8C-%EC%96%B4%EB%96%A4-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%AD%EC%A0%9C-%EB%B0%8F-%EC%88%98%EC%A0%95-%EC%8B%9C-1%EC%B0%A8-%EC%BA%90%EC%8B%9C%EC%97%90%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%ED%98%84%EC%83%81-flush%EC%9D%98-%EC%A7%84%EC%A7%9C-%EC%9D%98%EB%AF%B8](https://velog.io/@chosj1526/JPA-commit%EA%B3%BC-flush%EC%97%90-%EA%B4%80%ED%95%B4-%EC%98%81%EC%86%8D-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EC%84%B8%EC%84%B8%ED%95%98%EA%B2%8C-%EC%96%B4%EB%96%A4-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%AD%EC%A0%9C-%EB%B0%8F-%EC%88%98%EC%A0%95-%EC%8B%9C-1%EC%B0%A8-%EC%BA%90%EC%8B%9C%EC%97%90%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%ED%98%84%EC%83%81-flush%EC%9D%98-%EC%A7%84%EC%A7%9C-%EC%9D%98%EB%AF%B8)
- [https://cla9.tistory.com/100](https://cla9.tistory.com/100) 
- [https://yjksw.github.io/jpa-default-batch-fetch-size-not-working/](https://yjksw.github.io/jpa-default-batch-fetch-size-not-working/)
- [https://granger.tistory.com/67](https://granger.tistory.com/67)
- [https://prasanthmathialagan.wordpress.com/2017/04/20/beware-of-hibernate-batch-fetching/](https://prasanthmathialagan.wordpress.com/2017/04/20/beware-of-hibernate-batch-fetching/)
- [https://jojoldu.tistory.com/414](https://jojoldu.tistory.com/414)
- [https://multifrontgarden.tistory.com/280](https://multifrontgarden.tistory.com/280)
- [https://ilovepotato.tistory.com/36](https://ilovepotato.tistory.com/36)
- [https://resilient-923.tistory.com/417](https://resilient-923.tistory.com/417)
- [https://loosie.tistory.com/788#@OneToMany%EB%82%98_@ManyToOne%EC%97%90%EC%84%9C%EB%8A%94_%EC%99%9C_LAZY%EA%B0%80_%EB%8F%99%EC%9E%91%ED%95%A0%EA%B9%8C](https://loosie.tistory.com/788#@OneToMany%EB%82%98_@ManyToOne%EC%97%90%EC%84%9C%EB%8A%94_%EC%99%9C_LAZY%EA%B0%80_%EB%8F%99%EC%9E%91%ED%95%A0%EA%B9%8C)
